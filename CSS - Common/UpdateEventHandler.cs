using Microsoft.SqlServer.Server;
using Sandbox.Game.Localization;
using Sandbox.ModAPI.Ingame;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CSS_Common {
	/// <summary>
	/// Represents the method that will handle an event when the event provides data.
	/// (Space Engineers Prohibits mscorlib's version 🤷)
	/// </summary>
	/// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">An object that contains the event data.</param>
	public delegate void EventHandler<TEventArgs>(object sender, TEventArgs e);

	/// <summary>
	/// Encapsulates arguments passed to UpdateEventHandlers.
	/// </summary>
	public class UpdateEventArgs : EventArgs {
		public readonly string argument;
		public readonly UpdateType updateSource;

		public UpdateEventArgs(string argument, UpdateType updateSource) {
			this.argument = argument;
			this.updateSource = updateSource;
		}
	}

	/// <summary>
	/// Contains target UpdateType and other information for debugging.
	/// </summary>
	public struct EventHandlerMeta {
		public EventHandlerMeta(UpdateType TargetUpdateType, string FriendlyName) {
			this.TargetUpdateType = TargetUpdateType;
			this.FriendlyName = FriendlyName;
			TimeSubscribed = DateTime.UtcNow;
		}
		public override string ToString() {
			return $"[TargetUpdateType: {TargetUpdateType.ToString()}; FriendlyName: {FriendlyName}; TimeSubscribed: {TimeSubscribed.ToString()}]";
		}
		public UpdateType TargetUpdateType;
		public string FriendlyName;
		public DateTime TimeSubscribed;
	};

/// <summary>
/// Allows easily subscribing event handlers.
/// UpdateNone events will be called on every update.
/// Note: this does not set Runtime.UpdateFrequency.
/// </summary>
public class UpdateEventHandlers {
		/// <summary>
		/// If your EH is assigned to multiple UpdateEvents, use this instead.
		/// Event handers here will not be executed more than once per cycle.
		/// </summary>
		public Dictionary<EventHandler<UpdateEventArgs>, EventHandlerMeta> Subscribers = new Dictionary<EventHandler<UpdateEventArgs>, EventHandlerMeta>();

		/// <summary>
		/// If your EH is only assigned to a single UpdateEvent, use this.
		/// Subscribing to multiple events may lead to multiple invocations in one cycle.
		/// </summary>
		public event EventHandler<UpdateEventArgs>
			None, //
			Terminal, //1
			Trigger, //2
			Mod, //8
			Script, //16
			Update1, //32
			Update10, //64
			Update100, //128
			Once, //256
			IGC; //512

		/// <summary>
		/// Constructs UpdateEventHandlerActions array.
		/// </summary>
		public UpdateEventHandlers() {
		}

		/// <summary>
		/// Run subscribed event handlers.
		/// </summary>
		/// <param name="argument">Main's argument parameter</param>
		/// <param name="updateSource">Main's updateSource</param>
		public void CallUpdateEventHandlers(string argument, UpdateType updateSource) {
			UpdateEventArgs Args = new UpdateEventArgs(argument, updateSource);

			// If you have a DRY way that doesn't involving updating a list on every call: send me an email 🤷
			None?.Invoke(this, Args); // Always invoked
			if (updateSource.HasFlag(UpdateType.Terminal)) Terminal?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Trigger)) Trigger?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Mod)) Mod?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Script)) Script?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Update1)) Update1?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Update10)) Update10?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Update100)) Update100?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Once)) Once?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.IGC)) IGC?.Invoke(this, Args);

			foreach (
			KeyValuePair<EventHandler<UpdateEventArgs>, EventHandlerMeta> EH in
			Subscribers.Where(pair => (updateSource & pair.Value.TargetUpdateType) != 0 || pair.Value.TargetUpdateType == UpdateType.None)) {
				EH.Key.Invoke(this, Args);
			}
		}
	}
}
