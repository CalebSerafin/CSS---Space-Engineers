using Microsoft.SqlServer.Server;
using Sandbox.ModAPI.Ingame;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CSS_Common {
	/// <summary>
	/// Represents the method that will handle an event when the event provides data.
	/// (Space Engineers Prohibits mscorlib's version 🤷)
	/// </summary>
	/// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
	/// <param name="sender">The source of the event.</param>
	/// <param name="e">An object that contains the event data.</param>
	public delegate void EventHandler<TEventArgs>(object sender, TEventArgs e);

	/// <summary>
	/// Encapsulates arguments passed to UpdateEventHandlers.
	/// </summary>
	public class UpdateEventArgs : EventArgs {
		public readonly string argument;
		public readonly UpdateType updateSource;

		public UpdateEventArgs(string argument, UpdateType updateSource) {
			this.argument = argument;
			this.updateSource = updateSource;
		}
	}

	/// <summary>
	/// Allows easily subscribing event handlers.
	/// UpdateNone events will be called on every update.
	/// Note: this does not set Runtime.UpdateFrequency/
	/// </summary>
	public class UpdateEventHandlers {
		/// <summary>
		/// Event handers here will not be executed more than once per cycle.
		/// </summary>
		public Dictionary<EventHandler<UpdateEventArgs>, UpdateType> Subscribers = new Dictionary<EventHandler<UpdateEventArgs>, UpdateType>();

		/// <summary>
		/// Subscribe to this event handler. Subscribing to multiple events may lead to multiple invocations in one cycle.
		/// </summary>
		public event EventHandler<UpdateEventArgs>
			None, //
			Terminal, //1
			Trigger, //2
			Mod, //8
			Script, //16
			Update1, //32
			Update10, //64
			Update100, //128
			Once, //256
			IGC; //512

		/// <summary>
		/// Constructs UpdateEventHandlerActions array.
		/// </summary>
		public UpdateEventHandlers() {
		}

		/// <summary>
		/// Run subscribed event handlers.
		/// </summary>
		/// <param name="argument">Main's argument parameter</param>
		/// <param name="updateSource">Main's updateSource</param>
		public void CallUpdateEventHandlers(string argument, UpdateType updateSource) {
			UpdateEventArgs Args = new UpdateEventArgs(argument, updateSource);

			// If you have a DRY way that doesn't involving updating a list on every call: send me an email 🤷
			if (updateSource.HasFlag(UpdateType.None)) None?.Invoke(this, Args); // Always invoked
			if (updateSource.HasFlag(UpdateType.Terminal)) Terminal?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Trigger)) Trigger?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Mod)) Mod?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Script)) Script?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Update1)) Update1?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Update10)) Update10?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Update100)) Update100?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.Once)) Once?.Invoke(this, Args);
			if (updateSource.HasFlag(UpdateType.IGC)) IGC?.Invoke(this, Args);

			foreach (KeyValuePair<EventHandler<UpdateEventArgs>, UpdateType> EH in Subscribers.Where(pair => (updateSource & pair.Value) != 0 || pair.Value == UpdateType.None)) {
				EH.Key.Invoke(this, Args);
			}
		}
	}
}
